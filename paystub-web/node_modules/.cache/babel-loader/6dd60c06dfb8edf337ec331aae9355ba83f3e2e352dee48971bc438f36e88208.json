{"ast":null,"code":"import { PDFDocument } from 'pdf-lib';\nimport * as pdfjsLib from 'pdfjs-dist';\n\n// Set the worker source for PDF.js\npdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;\n\n/**\n * Extract text from a PDF\n * @param {ArrayBuffer} pdfData - The PDF file data\n * @param {number} pageNumber - The page number to extract text from (1-indexed)\n * @returns {Promise<string>} The extracted text\n */\nconst extractTextFromPdf = async (pdfData, pageNumber) => {\n  try {\n    // Load the PDF document\n    const loadingTask = pdfjsLib.getDocument({\n      data: pdfData\n    });\n    const pdf = await loadingTask.promise;\n\n    // Get the specified page\n    const page = await pdf.getPage(pageNumber);\n\n    // Extract text content\n    const textContent = await page.getTextContent();\n\n    // Concatenate the text items\n    const text = textContent.items.map(item => item.str).join('\\n');\n    return text;\n  } catch (error) {\n    console.error(\"Error extracting text from PDF:\", error);\n    return \"\";\n  }\n};\n\n/**\n * Extract information from PDF text content (similar to Python's extract_info)\n * @param {string} text - The text content extracted from the PDF\n * @returns {Object} Object containing name, date, amount, and company\n */\nexport const extractInformation = text => {\n  console.log(\"Full extracted text:\", text);\n  console.log(\"------------------------\");\n\n  // Split text similar to Python version\n  const parts = text.split(\"4300\", 1);\n  const processText = parts.length > 1 ? parts[1] : text;\n\n  // Extract name using regex\n  const nameMatch = processText.match(/([A-Z][A-Za-z\\s]+)\\n/);\n  const name = nameMatch ? nameMatch[1].trim() : \"Unknown\";\n\n  // Extract date using regex\n  const dateMatch = processText.match(/Cheque Date:?\\s*(.*?)(?:\\n|$)/i);\n  let date = \"Unknown_Date\";\n  if (dateMatch) {\n    const dateStr = dateMatch[1].trim();\n    console.log(`Extracted date string: '${dateStr}'`);\n\n    // Try different date formats\n    const dateFormats = [{\n      regex: /(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})/,\n      format: m => `${m[3]}-${m[2].padStart(2, '0')}-${m[1].padStart(2, '0')}`\n    },\n    // dd/mm/yyyy\n    {\n      regex: /(\\d{1,2})-(\\d{1,2})-(\\d{4})/,\n      format: m => `${m[3]}-${m[2].padStart(2, '0')}-${m[1].padStart(2, '0')}`\n    },\n    // dd-mm-yyyy\n    {\n      regex: /(\\d{1,2})\\/(\\d{1,2})\\/(\\d{2})/,\n      format: m => `20${m[3]}-${m[2].padStart(2, '0')}-${m[1].padStart(2, '0')}`\n    },\n    // dd/mm/yy\n    {\n      regex: /(\\d{1,2})-(\\d{1,2})-(\\d{2})/,\n      format: m => `20${m[3]}-${m[2].padStart(2, '0')}-${m[1].padStart(2, '0')}`\n    },\n    // dd-mm-yy\n    {\n      regex: /(\\w+)\\s+(\\d{1,2}),\\s+(\\d{4})/,\n      format: m => {\n        const months = {\n          'January': '01',\n          'February': '02',\n          'March': '03',\n          'April': '04',\n          'May': '05',\n          'June': '06',\n          'July': '07',\n          'August': '08',\n          'September': '09',\n          'October': '10',\n          'November': '11',\n          'December': '12'\n        };\n        return `${m[3]}-${months[m[1]] || '01'}-${m[2].padStart(2, '0')}`;\n      }\n    } // Month dd, yyyy\n    ];\n    for (const format of dateFormats) {\n      const match = dateStr.match(format.regex);\n      if (match) {\n        date = format.format(match);\n        console.log(`Parsed date: ${date}`);\n        break;\n      }\n    }\n  } else {\n    console.log(\"No date found in the text\");\n  }\n\n  // Extract amount (Net Pay)\n  let amount = null;\n  const amountMatch = processText.match(/Net Pay:?\\s*\\$?([\\d,]+\\.\\d{2})/i);\n  if (amountMatch) {\n    const amountStr = amountMatch[1].replace(',', '');\n    amount = parseFloat(amountStr);\n    console.log(`Extracted amount: $${amount}`);\n  } else {\n    console.log(\"No amount found in the text\");\n  }\n\n  // Extract company\n  let company = \"Unknown Company\";\n  const companyMatch = processText.match(/Company:?\\s*(.*?)(?:\\n|$)/i);\n  if (companyMatch) {\n    company = companyMatch[1].trim();\n    console.log(`Extracted company: ${company}`);\n  } else {\n    console.log(\"No company found in the text\");\n  }\n  console.log(`Final result - Name: ${name}, Date: ${date}, Amount: $${amount}, Company: ${company}`);\n  return {\n    name,\n    date,\n    amount,\n    company\n  };\n};\n\n/**\n * Create a copy of an ArrayBuffer\n * @param {ArrayBuffer} arrayBuffer - The ArrayBuffer to copy\n * @returns {ArrayBuffer} A new ArrayBuffer with the same content\n */\nconst copyArrayBuffer = arrayBuffer => {\n  const copy = new ArrayBuffer(arrayBuffer.byteLength);\n  new Uint8Array(copy).set(new Uint8Array(arrayBuffer));\n  return copy;\n};\n\n/**\n * Split a PDF into individual pages and extract information\n * @param {ArrayBuffer} pdfData - The PDF file data\n * @param {Function} progressCallback - Callback for progress updates (0-100)\n * @returns {Promise<Array>} Array of objects with page data and extracted info\n */\nexport const splitPdf = async (pdfData, progressCallback = () => {}) => {\n  try {\n    // Make a copy of the array buffer for pdf.js\n    const pdfJsBuffer = copyArrayBuffer(pdfData);\n\n    // Load PDF document for processing pages\n    progressCallback(5);\n    const pdfjsDoc = await pdfjsLib.getDocument({\n      data: pdfJsBuffer\n    }).promise;\n    const pageCount = pdfjsDoc.numPages;\n    console.log(`PDF has ${pageCount} pages`);\n    progressCallback(10);\n\n    // Make another copy for pdf-lib\n    const pdfLibBuffer = copyArrayBuffer(pdfData);\n\n    // Load PDF document for creating individual PDFs\n    const pdfDoc = await PDFDocument.load(pdfLibBuffer);\n    progressCallback(15);\n    const results = [];\n\n    // Process each page - following the Python implementation's logic\n    for (let i = 0; i < pageCount; i++) {\n      const pageNumber = i + 1;\n      const progressStart = 15;\n      const progressPerPage = 80 / pageCount;\n      const currentProgress = progressStart + progressPerPage * i;\n      progressCallback(currentProgress);\n      console.log(`Processing page ${pageNumber}/${pageCount}`);\n      try {\n        // Extract text content\n        const page = await pdfjsDoc.getPage(pageNumber);\n        const textContent = await page.getTextContent();\n        const text = textContent.items.map(item => item.str).join('\\n');\n\n        // Extract information\n        const {\n          name,\n          date,\n          amount,\n          company\n        } = extractInformation(text);\n\n        // Create a new document with just this page\n        const newPdf = await PDFDocument.create();\n        const [copiedPage] = await newPdf.copyPages(pdfDoc, [i]);\n        newPdf.addPage(copiedPage);\n\n        // Save the new PDF\n        const pdfBytes = await newPdf.save();\n\n        // Add to results\n        results.push({\n          pageNumber,\n          name,\n          date,\n          amount,\n          company,\n          filename: `${name} ${date}.pdf`,\n          pdfBytes: pdfBytes\n        });\n        progressCallback(currentProgress + progressPerPage * 0.8);\n      } catch (error) {\n        console.error(`Error processing page ${pageNumber}:`, error);\n        // Continue with next page despite errors\n      }\n    }\n    progressCallback(100);\n    return results;\n  } catch (error) {\n    console.error(\"Error splitting PDF:\", error);\n    throw new Error(`Failed to split PDF: ${error.message}`);\n  }\n};","map":{"version":3,"names":["PDFDocument","pdfjsLib","GlobalWorkerOptions","workerSrc","version","extractTextFromPdf","pdfData","pageNumber","loadingTask","getDocument","data","pdf","promise","page","getPage","textContent","getTextContent","text","items","map","item","str","join","error","console","extractInformation","log","parts","split","processText","length","nameMatch","match","name","trim","dateMatch","date","dateStr","dateFormats","regex","format","m","padStart","months","amount","amountMatch","amountStr","replace","parseFloat","company","companyMatch","copyArrayBuffer","arrayBuffer","copy","ArrayBuffer","byteLength","Uint8Array","set","splitPdf","progressCallback","pdfJsBuffer","pdfjsDoc","pageCount","numPages","pdfLibBuffer","pdfDoc","load","results","i","progressStart","progressPerPage","currentProgress","newPdf","create","copiedPage","copyPages","addPage","pdfBytes","save","push","filename","Error","message"],"sources":["/Users/mattermost/Documents/paystub/paystub-web/src/utils/pdfProcessor.js"],"sourcesContent":["import { PDFDocument } from 'pdf-lib';\nimport * as pdfjsLib from 'pdfjs-dist';\n\n// Set the worker source for PDF.js\npdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;\n\n/**\n * Extract text from a PDF\n * @param {ArrayBuffer} pdfData - The PDF file data\n * @param {number} pageNumber - The page number to extract text from (1-indexed)\n * @returns {Promise<string>} The extracted text\n */\nconst extractTextFromPdf = async (pdfData, pageNumber) => {\n  try {\n    // Load the PDF document\n    const loadingTask = pdfjsLib.getDocument({ data: pdfData });\n    const pdf = await loadingTask.promise;\n    \n    // Get the specified page\n    const page = await pdf.getPage(pageNumber);\n    \n    // Extract text content\n    const textContent = await page.getTextContent();\n    \n    // Concatenate the text items\n    const text = textContent.items.map(item => item.str).join('\\n');\n    \n    return text;\n  } catch (error) {\n    console.error(\"Error extracting text from PDF:\", error);\n    return \"\";\n  }\n};\n\n/**\n * Extract information from PDF text content (similar to Python's extract_info)\n * @param {string} text - The text content extracted from the PDF\n * @returns {Object} Object containing name, date, amount, and company\n */\nexport const extractInformation = (text) => {\n  console.log(\"Full extracted text:\", text);\n  console.log(\"------------------------\");\n  \n  // Split text similar to Python version\n  const parts = text.split(\"4300\", 1);\n  const processText = parts.length > 1 ? parts[1] : text;\n  \n  // Extract name using regex\n  const nameMatch = processText.match(/([A-Z][A-Za-z\\s]+)\\n/);\n  const name = nameMatch ? nameMatch[1].trim() : \"Unknown\";\n  \n  // Extract date using regex\n  const dateMatch = processText.match(/Cheque Date:?\\s*(.*?)(?:\\n|$)/i);\n  let date = \"Unknown_Date\";\n  \n  if (dateMatch) {\n    const dateStr = dateMatch[1].trim();\n    console.log(`Extracted date string: '${dateStr}'`);\n    \n    // Try different date formats\n    const dateFormats = [\n      { regex: /(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})/, format: (m) => `${m[3]}-${m[2].padStart(2, '0')}-${m[1].padStart(2, '0')}` }, // dd/mm/yyyy\n      { regex: /(\\d{1,2})-(\\d{1,2})-(\\d{4})/, format: (m) => `${m[3]}-${m[2].padStart(2, '0')}-${m[1].padStart(2, '0')}` }, // dd-mm-yyyy\n      { regex: /(\\d{1,2})\\/(\\d{1,2})\\/(\\d{2})/, format: (m) => `20${m[3]}-${m[2].padStart(2, '0')}-${m[1].padStart(2, '0')}` }, // dd/mm/yy\n      { regex: /(\\d{1,2})-(\\d{1,2})-(\\d{2})/, format: (m) => `20${m[3]}-${m[2].padStart(2, '0')}-${m[1].padStart(2, '0')}` }, // dd-mm-yy\n      { regex: /(\\w+)\\s+(\\d{1,2}),\\s+(\\d{4})/, format: (m) => {\n        const months = { 'January': '01', 'February': '02', 'March': '03', 'April': '04', 'May': '05', 'June': '06', \n                         'July': '07', 'August': '08', 'September': '09', 'October': '10', 'November': '11', 'December': '12' };\n        return `${m[3]}-${months[m[1]] || '01'}-${m[2].padStart(2, '0')}`;\n      }}, // Month dd, yyyy\n    ];\n    \n    for (const format of dateFormats) {\n      const match = dateStr.match(format.regex);\n      if (match) {\n        date = format.format(match);\n        console.log(`Parsed date: ${date}`);\n        break;\n      }\n    }\n  } else {\n    console.log(\"No date found in the text\");\n  }\n  \n  // Extract amount (Net Pay)\n  let amount = null;\n  const amountMatch = processText.match(/Net Pay:?\\s*\\$?([\\d,]+\\.\\d{2})/i);\n  if (amountMatch) {\n    const amountStr = amountMatch[1].replace(',', '');\n    amount = parseFloat(amountStr);\n    console.log(`Extracted amount: $${amount}`);\n  } else {\n    console.log(\"No amount found in the text\");\n  }\n  \n  // Extract company\n  let company = \"Unknown Company\";\n  const companyMatch = processText.match(/Company:?\\s*(.*?)(?:\\n|$)/i);\n  if (companyMatch) {\n    company = companyMatch[1].trim();\n    console.log(`Extracted company: ${company}`);\n  } else {\n    console.log(\"No company found in the text\");\n  }\n  \n  console.log(`Final result - Name: ${name}, Date: ${date}, Amount: $${amount}, Company: ${company}`);\n  return { name, date, amount, company };\n};\n\n/**\n * Create a copy of an ArrayBuffer\n * @param {ArrayBuffer} arrayBuffer - The ArrayBuffer to copy\n * @returns {ArrayBuffer} A new ArrayBuffer with the same content\n */\nconst copyArrayBuffer = (arrayBuffer) => {\n  const copy = new ArrayBuffer(arrayBuffer.byteLength);\n  new Uint8Array(copy).set(new Uint8Array(arrayBuffer));\n  return copy;\n};\n\n/**\n * Split a PDF into individual pages and extract information\n * @param {ArrayBuffer} pdfData - The PDF file data\n * @param {Function} progressCallback - Callback for progress updates (0-100)\n * @returns {Promise<Array>} Array of objects with page data and extracted info\n */\nexport const splitPdf = async (pdfData, progressCallback = () => {}) => {\n  try {\n    // Make a copy of the array buffer for pdf.js\n    const pdfJsBuffer = copyArrayBuffer(pdfData);\n    \n    // Load PDF document for processing pages\n    progressCallback(5);\n    const pdfjsDoc = await pdfjsLib.getDocument({ data: pdfJsBuffer }).promise;\n    const pageCount = pdfjsDoc.numPages;\n    console.log(`PDF has ${pageCount} pages`);\n    progressCallback(10);\n    \n    // Make another copy for pdf-lib\n    const pdfLibBuffer = copyArrayBuffer(pdfData);\n    \n    // Load PDF document for creating individual PDFs\n    const pdfDoc = await PDFDocument.load(pdfLibBuffer);\n    progressCallback(15);\n    \n    const results = [];\n    \n    // Process each page - following the Python implementation's logic\n    for (let i = 0; i < pageCount; i++) {\n      const pageNumber = i + 1;\n      const progressStart = 15;\n      const progressPerPage = 80 / pageCount;\n      const currentProgress = progressStart + (progressPerPage * i);\n      \n      progressCallback(currentProgress);\n      console.log(`Processing page ${pageNumber}/${pageCount}`);\n      \n      try {\n        // Extract text content\n        const page = await pdfjsDoc.getPage(pageNumber);\n        const textContent = await page.getTextContent();\n        const text = textContent.items.map(item => item.str).join('\\n');\n        \n        // Extract information\n        const { name, date, amount, company } = extractInformation(text);\n        \n        // Create a new document with just this page\n        const newPdf = await PDFDocument.create();\n        const [copiedPage] = await newPdf.copyPages(pdfDoc, [i]);\n        newPdf.addPage(copiedPage);\n        \n        // Save the new PDF\n        const pdfBytes = await newPdf.save();\n        \n        // Add to results\n        results.push({\n          pageNumber,\n          name,\n          date,\n          amount,\n          company,\n          filename: `${name} ${date}.pdf`,\n          pdfBytes: pdfBytes\n        });\n        \n        progressCallback(currentProgress + (progressPerPage * 0.8));\n      } catch (error) {\n        console.error(`Error processing page ${pageNumber}:`, error);\n        // Continue with next page despite errors\n      }\n    }\n    \n    progressCallback(100);\n    return results;\n  } catch (error) {\n    console.error(\"Error splitting PDF:\", error);\n    throw new Error(`Failed to split PDF: ${error.message}`);\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}