{"ast":null,"code":"/**\n * Database manager for the Paystub application using IndexedDB\n */\n\nconst DB_NAME = 'paystub_db';\nconst DB_VERSION = 1;\n\n/**\n * Initialize the database\n * @returns {Promise<IDBDatabase>} The database instance\n */\nexport const initDatabase = () => {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    request.onerror = event => {\n      console.error(\"Database error:\", event.target.error);\n      reject(event.target.error);\n    };\n    request.onsuccess = event => {\n      const db = event.target.result;\n      resolve(db);\n    };\n    request.onupgradeneeded = event => {\n      const db = event.target.result;\n\n      // Create individuals store with name as key path\n      if (!db.objectStoreNames.contains('individuals')) {\n        const individualsStore = db.createObjectStore('individuals', {\n          keyPath: 'id',\n          autoIncrement: true\n        });\n        individualsStore.createIndex('name', 'name', {\n          unique: true\n        });\n      }\n\n      // Create pay statements store\n      if (!db.objectStoreNames.contains('pay_statements')) {\n        const statementsStore = db.createObjectStore('pay_statements', {\n          keyPath: 'id',\n          autoIncrement: true\n        });\n        statementsStore.createIndex('individual_id', 'individualId', {\n          unique: false\n        });\n        statementsStore.createIndex('individual_date', ['individualId', 'date'], {\n          unique: true\n        });\n      }\n    };\n  });\n};\n\n/**\n * Insert a new individual into the database\n * @param {Object} individual - The individual to insert\n * @returns {Promise<number>} The ID of the inserted individual\n */\nexport const insertIndividual = async individual => {\n  const db = await initDatabase();\n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(['individuals'], 'readwrite');\n    const store = transaction.objectStore('individuals');\n\n    // Check if individual already exists\n    const nameIndex = store.index('name');\n    const getRequest = nameIndex.get(individual.name);\n    getRequest.onsuccess = event => {\n      if (event.target.result) {\n        // Individual already exists, return existing ID\n        resolve(event.target.result.id);\n      } else {\n        // Insert new individual\n        const addRequest = store.add(individual);\n        addRequest.onsuccess = event => {\n          resolve(event.target.result);\n        };\n        addRequest.onerror = event => {\n          console.error(\"Error adding individual:\", event.target.error);\n          reject(event.target.error);\n        };\n      }\n    };\n    getRequest.onerror = event => {\n      console.error(\"Error checking individual:\", event.target.error);\n      reject(event.target.error);\n    };\n  });\n};\n\n/**\n * Insert a pay statement into the database\n * @param {Object} statement - The pay statement to insert\n * @returns {Promise<boolean>} Whether the statement was inserted\n */\nexport const insertPayStatement = async statement => {\n  const db = await initDatabase();\n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(['pay_statements'], 'readwrite');\n    const store = transaction.objectStore('pay_statements');\n\n    // Check if statement already exists for this individual and date\n    const index = store.index('individual_date');\n    const getRequest = index.get([statement.individualId, statement.date]);\n    getRequest.onsuccess = event => {\n      if (event.target.result) {\n        // Statement already exists\n        console.log(`Pay statement already exists for individual ${statement.individualId} on ${statement.date}`);\n        resolve(false);\n      } else {\n        // Add extraction date\n        const statementWithDate = {\n          ...statement,\n          extractionDate: new Date().toISOString().split('T')[0]\n        };\n\n        // Insert new statement\n        const addRequest = store.add(statementWithDate);\n        addRequest.onsuccess = () => {\n          console.log(`Inserted new pay statement for ${statement.individualId}: ${statement.filename}`);\n          resolve(true);\n        };\n        addRequest.onerror = event => {\n          console.error(\"Error adding pay statement:\", event.target.error);\n          reject(event.target.error);\n        };\n      }\n    };\n    getRequest.onerror = event => {\n      console.error(\"Error checking pay statement:\", event.target.error);\n      reject(event.target.error);\n    };\n  });\n};\n\n/**\n * Update individual information\n * @param {number} id - The individual's ID\n * @param {Object} updates - The fields to update\n * @returns {Promise<boolean>} Whether the update was successful\n */\nexport const updateIndividualInfo = async (id, updates) => {\n  const db = await initDatabase();\n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(['individuals'], 'readwrite');\n    const store = transaction.objectStore('individuals');\n\n    // Get the current individual\n    const getRequest = store.get(id);\n    getRequest.onsuccess = event => {\n      const individual = event.target.result;\n      if (!individual) {\n        reject(new Error(`Individual with ID ${id} not found`));\n        return;\n      }\n\n      // Update fields\n      const updatedIndividual = {\n        ...individual,\n        ...updates\n      };\n\n      // Put back the updated individual\n      const putRequest = store.put(updatedIndividual);\n      putRequest.onsuccess = () => {\n        console.log(`Updated information for individual ${id}`);\n        resolve(true);\n      };\n      putRequest.onerror = event => {\n        console.error(\"Error updating individual:\", event.target.error);\n        reject(event.target.error);\n      };\n    };\n    getRequest.onerror = event => {\n      console.error(\"Error getting individual:\", event.target.error);\n      reject(event.target.error);\n    };\n  });\n};\n\n/**\n * Get all individuals\n * @returns {Promise<Array>} Array of individuals\n */\nexport const getIndividuals = async () => {\n  const db = await initDatabase();\n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(['individuals'], 'readonly');\n    const store = transaction.objectStore('individuals');\n    const request = store.getAll();\n    request.onsuccess = event => {\n      resolve(event.target.result);\n    };\n    request.onerror = event => {\n      console.error(\"Error getting individuals:\", event.target.error);\n      reject(event.target.error);\n    };\n  });\n};\n\n/**\n * Get pay statements for an individual\n * @param {number} individualId - The individual's ID\n * @returns {Promise<Array>} Array of pay statements\n */\nexport const getPayStatements = async individualId => {\n  const db = await initDatabase();\n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(['pay_statements'], 'readonly');\n    const store = transaction.objectStore('pay_statements');\n    const index = store.index('individual_id');\n    const request = index.getAll(individualId);\n    request.onsuccess = event => {\n      resolve(event.target.result);\n    };\n    request.onerror = event => {\n      console.error(\"Error getting pay statements:\", event.target.error);\n      reject(event.target.error);\n    };\n  });\n};\n\n/**\n * Get all pay statements\n * @returns {Promise<Array>} Array of all pay statements\n */\nexport const getAllPayStatements = async () => {\n  const db = await initDatabase();\n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(['pay_statements'], 'readonly');\n    const store = transaction.objectStore('pay_statements');\n    const request = store.getAll();\n    request.onsuccess = event => {\n      resolve(event.target.result);\n    };\n    request.onerror = event => {\n      console.error(\"Error getting all pay statements:\", event.target.error);\n      reject(event.target.error);\n    };\n  });\n};\n\n/**\n * Delete a pay statement by ID\n * @param {number} id - The ID of the pay statement to delete\n * @returns {Promise<boolean>} Whether the delete was successful\n */\nexport const deletePayStatement = async id => {\n  const db = await initDatabase();\n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(['pay_statements'], 'readwrite');\n    const store = transaction.objectStore('pay_statements');\n    const request = store.delete(id);\n    request.onsuccess = () => {\n      console.log(`Deleted pay statement with ID ${id}`);\n      resolve(true);\n    };\n    request.onerror = event => {\n      console.error(\"Error deleting pay statement:\", event.target.error);\n      reject(event.target.error);\n    };\n  });\n};\n\n/**\n * Delete an individual by ID and all their associated pay statements\n * @param {number} id - The ID of the individual to delete\n * @returns {Promise<boolean>} Whether the delete was successful\n */\nexport const deleteIndividual = async id => {\n  const db = await initDatabase();\n  return new Promise((resolve, reject) => {\n    try {\n      // Use a transaction to ensure both delete operations are atomic\n      const transaction = db.transaction(['individuals', 'pay_statements'], 'readwrite');\n\n      // Delete the individual\n      const individualStore = transaction.objectStore('individuals');\n      const deleteIndividualRequest = individualStore.delete(id);\n\n      // Delete all associated pay statements\n      const statementsStore = transaction.objectStore('pay_statements');\n      const index = statementsStore.index('individual_id');\n      const getStatementsRequest = index.getAll(id);\n      getStatementsRequest.onsuccess = () => {\n        const statements = getStatementsRequest.result;\n\n        // Delete each statement\n        let deletedCount = 0;\n        if (statements.length === 0) {\n          // No statements to delete, transaction will complete\n          console.log(`Deleted individual with ID ${id} (no statements found)`);\n        } else {\n          for (const statement of statements) {\n            const deleteStatementRequest = statementsStore.delete(statement.id);\n            deleteStatementRequest.onsuccess = () => {\n              deletedCount++;\n              if (deletedCount === statements.length) {\n                console.log(`Deleted individual with ID ${id} and ${deletedCount} pay statements`);\n              }\n            };\n            deleteStatementRequest.onerror = event => {\n              console.error(`Error deleting statement ${statement.id}:`, event.target.error);\n            };\n          }\n        }\n      };\n      getStatementsRequest.onerror = event => {\n        console.error(\"Error getting statements for individual:\", event.target.error);\n      };\n      transaction.oncomplete = () => {\n        resolve(true);\n      };\n      transaction.onerror = event => {\n        console.error(\"Transaction error:\", event.target.error);\n        reject(event.target.error);\n      };\n    } catch (error) {\n      console.error(\"Error in deleteIndividual:\", error);\n      reject(error);\n    }\n  });\n};","map":{"version":3,"names":["DB_NAME","DB_VERSION","initDatabase","Promise","resolve","reject","request","indexedDB","open","onerror","event","console","error","target","onsuccess","db","result","onupgradeneeded","objectStoreNames","contains","individualsStore","createObjectStore","keyPath","autoIncrement","createIndex","unique","statementsStore","insertIndividual","individual","transaction","store","objectStore","nameIndex","index","getRequest","get","name","id","addRequest","add","insertPayStatement","statement","individualId","date","log","statementWithDate","extractionDate","Date","toISOString","split","filename","updateIndividualInfo","updates","Error","updatedIndividual","putRequest","put","getIndividuals","getAll","getPayStatements","getAllPayStatements","deletePayStatement","delete","deleteIndividual","individualStore","deleteIndividualRequest","getStatementsRequest","statements","deletedCount","length","deleteStatementRequest","oncomplete"],"sources":["/Users/mattermost/Documents/paystub/paystub-web/src/utils/databaseManager.js"],"sourcesContent":["/**\n * Database manager for the Paystub application using IndexedDB\n */\n\nconst DB_NAME = 'paystub_db';\nconst DB_VERSION = 1;\n\n/**\n * Initialize the database\n * @returns {Promise<IDBDatabase>} The database instance\n */\nexport const initDatabase = () => {\n  return new Promise((resolve, reject) => {\n    const request = indexedDB.open(DB_NAME, DB_VERSION);\n    \n    request.onerror = (event) => {\n      console.error(\"Database error:\", event.target.error);\n      reject(event.target.error);\n    };\n    \n    request.onsuccess = (event) => {\n      const db = event.target.result;\n      resolve(db);\n    };\n    \n    request.onupgradeneeded = (event) => {\n      const db = event.target.result;\n      \n      // Create individuals store with name as key path\n      if (!db.objectStoreNames.contains('individuals')) {\n        const individualsStore = db.createObjectStore('individuals', { keyPath: 'id', autoIncrement: true });\n        individualsStore.createIndex('name', 'name', { unique: true });\n      }\n      \n      // Create pay statements store\n      if (!db.objectStoreNames.contains('pay_statements')) {\n        const statementsStore = db.createObjectStore('pay_statements', { keyPath: 'id', autoIncrement: true });\n        statementsStore.createIndex('individual_id', 'individualId', { unique: false });\n        statementsStore.createIndex('individual_date', ['individualId', 'date'], { unique: true });\n      }\n    };\n  });\n};\n\n/**\n * Insert a new individual into the database\n * @param {Object} individual - The individual to insert\n * @returns {Promise<number>} The ID of the inserted individual\n */\nexport const insertIndividual = async (individual) => {\n  const db = await initDatabase();\n  \n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(['individuals'], 'readwrite');\n    const store = transaction.objectStore('individuals');\n    \n    // Check if individual already exists\n    const nameIndex = store.index('name');\n    const getRequest = nameIndex.get(individual.name);\n    \n    getRequest.onsuccess = (event) => {\n      if (event.target.result) {\n        // Individual already exists, return existing ID\n        resolve(event.target.result.id);\n      } else {\n        // Insert new individual\n        const addRequest = store.add(individual);\n        \n        addRequest.onsuccess = (event) => {\n          resolve(event.target.result);\n        };\n        \n        addRequest.onerror = (event) => {\n          console.error(\"Error adding individual:\", event.target.error);\n          reject(event.target.error);\n        };\n      }\n    };\n    \n    getRequest.onerror = (event) => {\n      console.error(\"Error checking individual:\", event.target.error);\n      reject(event.target.error);\n    };\n  });\n};\n\n/**\n * Insert a pay statement into the database\n * @param {Object} statement - The pay statement to insert\n * @returns {Promise<boolean>} Whether the statement was inserted\n */\nexport const insertPayStatement = async (statement) => {\n  const db = await initDatabase();\n  \n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(['pay_statements'], 'readwrite');\n    const store = transaction.objectStore('pay_statements');\n    \n    // Check if statement already exists for this individual and date\n    const index = store.index('individual_date');\n    const getRequest = index.get([statement.individualId, statement.date]);\n    \n    getRequest.onsuccess = (event) => {\n      if (event.target.result) {\n        // Statement already exists\n        console.log(`Pay statement already exists for individual ${statement.individualId} on ${statement.date}`);\n        resolve(false);\n      } else {\n        // Add extraction date\n        const statementWithDate = {\n          ...statement,\n          extractionDate: new Date().toISOString().split('T')[0]\n        };\n        \n        // Insert new statement\n        const addRequest = store.add(statementWithDate);\n        \n        addRequest.onsuccess = () => {\n          console.log(`Inserted new pay statement for ${statement.individualId}: ${statement.filename}`);\n          resolve(true);\n        };\n        \n        addRequest.onerror = (event) => {\n          console.error(\"Error adding pay statement:\", event.target.error);\n          reject(event.target.error);\n        };\n      }\n    };\n    \n    getRequest.onerror = (event) => {\n      console.error(\"Error checking pay statement:\", event.target.error);\n      reject(event.target.error);\n    };\n  });\n};\n\n/**\n * Update individual information\n * @param {number} id - The individual's ID\n * @param {Object} updates - The fields to update\n * @returns {Promise<boolean>} Whether the update was successful\n */\nexport const updateIndividualInfo = async (id, updates) => {\n  const db = await initDatabase();\n  \n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(['individuals'], 'readwrite');\n    const store = transaction.objectStore('individuals');\n    \n    // Get the current individual\n    const getRequest = store.get(id);\n    \n    getRequest.onsuccess = (event) => {\n      const individual = event.target.result;\n      \n      if (!individual) {\n        reject(new Error(`Individual with ID ${id} not found`));\n        return;\n      }\n      \n      // Update fields\n      const updatedIndividual = { ...individual, ...updates };\n      \n      // Put back the updated individual\n      const putRequest = store.put(updatedIndividual);\n      \n      putRequest.onsuccess = () => {\n        console.log(`Updated information for individual ${id}`);\n        resolve(true);\n      };\n      \n      putRequest.onerror = (event) => {\n        console.error(\"Error updating individual:\", event.target.error);\n        reject(event.target.error);\n      };\n    };\n    \n    getRequest.onerror = (event) => {\n      console.error(\"Error getting individual:\", event.target.error);\n      reject(event.target.error);\n    };\n  });\n};\n\n/**\n * Get all individuals\n * @returns {Promise<Array>} Array of individuals\n */\nexport const getIndividuals = async () => {\n  const db = await initDatabase();\n  \n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(['individuals'], 'readonly');\n    const store = transaction.objectStore('individuals');\n    const request = store.getAll();\n    \n    request.onsuccess = (event) => {\n      resolve(event.target.result);\n    };\n    \n    request.onerror = (event) => {\n      console.error(\"Error getting individuals:\", event.target.error);\n      reject(event.target.error);\n    };\n  });\n};\n\n/**\n * Get pay statements for an individual\n * @param {number} individualId - The individual's ID\n * @returns {Promise<Array>} Array of pay statements\n */\nexport const getPayStatements = async (individualId) => {\n  const db = await initDatabase();\n  \n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(['pay_statements'], 'readonly');\n    const store = transaction.objectStore('pay_statements');\n    const index = store.index('individual_id');\n    const request = index.getAll(individualId);\n    \n    request.onsuccess = (event) => {\n      resolve(event.target.result);\n    };\n    \n    request.onerror = (event) => {\n      console.error(\"Error getting pay statements:\", event.target.error);\n      reject(event.target.error);\n    };\n  });\n};\n\n/**\n * Get all pay statements\n * @returns {Promise<Array>} Array of all pay statements\n */\nexport const getAllPayStatements = async () => {\n  const db = await initDatabase();\n  \n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(['pay_statements'], 'readonly');\n    const store = transaction.objectStore('pay_statements');\n    const request = store.getAll();\n    \n    request.onsuccess = (event) => {\n      resolve(event.target.result);\n    };\n    \n    request.onerror = (event) => {\n      console.error(\"Error getting all pay statements:\", event.target.error);\n      reject(event.target.error);\n    };\n  });\n};\n\n/**\n * Delete a pay statement by ID\n * @param {number} id - The ID of the pay statement to delete\n * @returns {Promise<boolean>} Whether the delete was successful\n */\nexport const deletePayStatement = async (id) => {\n  const db = await initDatabase();\n  \n  return new Promise((resolve, reject) => {\n    const transaction = db.transaction(['pay_statements'], 'readwrite');\n    const store = transaction.objectStore('pay_statements');\n    \n    const request = store.delete(id);\n    \n    request.onsuccess = () => {\n      console.log(`Deleted pay statement with ID ${id}`);\n      resolve(true);\n    };\n    \n    request.onerror = (event) => {\n      console.error(\"Error deleting pay statement:\", event.target.error);\n      reject(event.target.error);\n    };\n  });\n};\n\n/**\n * Delete an individual by ID and all their associated pay statements\n * @param {number} id - The ID of the individual to delete\n * @returns {Promise<boolean>} Whether the delete was successful\n */\nexport const deleteIndividual = async (id) => {\n  const db = await initDatabase();\n  \n  return new Promise((resolve, reject) => {\n    try {\n      // Use a transaction to ensure both delete operations are atomic\n      const transaction = db.transaction(['individuals', 'pay_statements'], 'readwrite');\n      \n      // Delete the individual\n      const individualStore = transaction.objectStore('individuals');\n      const deleteIndividualRequest = individualStore.delete(id);\n      \n      // Delete all associated pay statements\n      const statementsStore = transaction.objectStore('pay_statements');\n      const index = statementsStore.index('individual_id');\n      const getStatementsRequest = index.getAll(id);\n      \n      getStatementsRequest.onsuccess = () => {\n        const statements = getStatementsRequest.result;\n        \n        // Delete each statement\n        let deletedCount = 0;\n        if (statements.length === 0) {\n          // No statements to delete, transaction will complete\n          console.log(`Deleted individual with ID ${id} (no statements found)`);\n        } else {\n          for (const statement of statements) {\n            const deleteStatementRequest = statementsStore.delete(statement.id);\n            \n            deleteStatementRequest.onsuccess = () => {\n              deletedCount++;\n              if (deletedCount === statements.length) {\n                console.log(`Deleted individual with ID ${id} and ${deletedCount} pay statements`);\n              }\n            };\n            \n            deleteStatementRequest.onerror = (event) => {\n              console.error(`Error deleting statement ${statement.id}:`, event.target.error);\n            };\n          }\n        }\n      };\n      \n      getStatementsRequest.onerror = (event) => {\n        console.error(\"Error getting statements for individual:\", event.target.error);\n      };\n      \n      transaction.oncomplete = () => {\n        resolve(true);\n      };\n      \n      transaction.onerror = (event) => {\n        console.error(\"Transaction error:\", event.target.error);\n        reject(event.target.error);\n      };\n    } catch (error) {\n      console.error(\"Error in deleteIndividual:\", error);\n      reject(error);\n    }\n  });\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}